import {
  S3Client,
  ListObjectsV2Command,
  CopyObjectCommand
} from "@aws-sdk/client-s3";

const s3 = new S3Client({ region: "ap-northeast-1" });

const DEV_BUCKET = process.env.DEV_BUCKET;
const PROD_BUCKET = process.env.PROD_BUCKET;

export const handler = async (event) => {
  // event.queryStringParameters?.dryRun が "true" の場合はコピーしない

  const dryRun = event.queryStringParameters?.dryRun === "true";

  const devList = await s3.send(new ListObjectsV2Command({ Bucket: DEV_BUCKET }));
  const prodList = await s3.send(new ListObjectsV2Command({ Bucket: PROD_BUCKET }));

  const prodMap = {};
  (prodList.Contents || []).forEach(o => prodMap[o.Key] = new Date(o.LastModified));

  // 同期すべきファイルリストを取得
  const toCopy = (devList.Contents || []).filter(obj => {
    const prodDate = prodMap[obj.Key];
    return !prodDate || new Date(obj.LastModified) > prodDate;
  });

  if (!dryRun) {
    // コピー実行
    const copyPromises = toCopy.map(obj =>
      s3.send(new CopyObjectCommand({
        Bucket: PROD_BUCKET,
        CopySource: `${DEV_BUCKET}/${obj.Key}`,
        Key: obj.Key
      }))
    );
    await Promise.all(copyPromises);
  }

  return {
    statusCode: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      dryRun,
      syncCount: toCopy.length,
      files: toCopy.map(obj => ({
        key: obj.Key,
        lastModified: obj.LastModified,
        size: obj.Size
      }))
    })
  };
};





{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:DescribeLogGroups",
        "logs:DescribeLogStreams",
        "logs:PutLogEvents"
      ],
      "Resource": "*"
    }
  ]
}


import {
  S3Client,
  ListObjectsV2Command,
  CopyObjectCommand
} from "@aws-sdk/client-s3";

const s3 = new S3Client({ region: "ap-northeast-1" });

const DEV_BUCKET = process.env.DEV_BUCKET;
const PROD_BUCKET = process.env.PROD_BUCKET;

export const handler = async () => {
  const devList = await s3.send(new ListObjectsV2Command({ Bucket: DEV_BUCKET }));
  const prodList = await s3.send(new ListObjectsV2Command({ Bucket: PROD_BUCKET }));

  const prodMap = {};
  (prodList.Contents || []).forEach(o => prodMap[o.Key] = new Date(o.LastModified));

  const toCopy = (devList.Contents || []).filter(obj => {
    const prodDate = prodMap[obj.Key];
    return !prodDate || new Date(obj.LastModified) > prodDate;
  });

  const copyPromises = toCopy.map(obj =>
    s3.send(new CopyObjectCommand({
      Bucket: PROD_BUCKET,
      CopySource: `${DEV_BUCKET}/${obj.Key}`,
      Key: obj.Key
    }))
  );

  await Promise.all(copyPromises);

  return {
    statusCode: 200,
    headers: { 'Access-Control-Allow-Origin': '*' },
    body: `Synced ${toCopy.length} files.`
  };
};






exports.handler = async () => {
  const html = `
  <!DOCTYPE html>
  <html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>S3同期ツール</title>
    <style>
      body { font-family: sans-serif; padding: 2em; }
      button { font-size: 16px; padding: 10px 20px; }
      #status { margin-top: 1em; }
    </style>
  </head>
  <body>
    <h1>S3バケット同期</h1>
    <button onclick="sync()">同期実行</button>
    <p id="status">未実行</p>

    <script>
      async function sync() {
        document.getElementById("status").innerText = "同期中...";
        try {
          const res = await fetch("/sync", { method: "POST" });
          const text = await res.text();
          document.getElementById("status").innerText = "完了: " + text;
        } catch (err) {
          document.getElementById("status").innerText = "エラー: " + err.message;
        }
      }
    </script>
  </body>
  </html>
  `;

  return {
    statusCode: 200,
    headers: {
      'Content-Type': 'text/html',
    },
    body: html
  };
};




const AWS = require('aws-sdk');
const s3 = new AWS.S3();

const DEV_BUCKET = process.env.DEV_BUCKET;
const PROD_BUCKET = process.env.PROD_BUCKET;

exports.handler = async () => {
  const devObjects = await s3.listObjectsV2({ Bucket: DEV_BUCKET }).promise();
  const prodObjects = await s3.listObjectsV2({ Bucket: PROD_BUCKET }).promise();

  const prodMap = {};
  (prodObjects.Contents || []).forEach(o => prodMap[o.Key] = new Date(o.LastModified));

  const toCopy = (devObjects.Contents || []).filter(obj => {
    const prodDate = prodMap[obj.Key];
    return !prodDate || new Date(obj.LastModified) > prodDate;
  });

  const copyPromises = toCopy.map(obj =>
    s3.copyObject({
      Bucket: PROD_BUCKET,
      CopySource: `/${DEV_BUCKET}/${encodeURIComponent(obj.Key)}`,
      Key: obj.Key
    }).promise()
  );

  await Promise.all(copyPromises);

  return {
    statusCode: 200,
    headers: { 'Access-Control-Allow-Origin': '*' },
    body: `Synced ${toCopy.length} files.`
  };
};






{
  "Effect": "Allow",
  "Action": [
    "s3:ListBucket",
    "s3:GetObject",
    "s3:PutObject",
    "s3:CopyObject"
  ],
  "Resource": [
    "arn:aws:s3:::maeda-pre-test",
    "arn:aws:s3:::maeda-pre-test/*",
    "arn:aws:s3:::maeda-prod-test",
    "arn:aws:s3:::maeda-prod-test/*"
  ]
}


{
  "statusCode": 200,
  "headers": {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "POST,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type"
  },
  "body": ""
}



{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowSpecificIP",
      "Effect": "Allow",
      "Principal": "*",
      "Action": "execute-api:Invoke",
      "Resource": "arn:aws:execute-api:ap-northeast-1:123456789012:your-api-id/*",
      "Condition": {
        "IpAddress": {
          "aws:SourceIp": [
            "203.0.113.10/32",   // ← 許可したいIPアドレス
            "198.51.100.0/24"    // ← 必要に応じて範囲も可
          ]
        }
      }
    }
  ]
}



body: JSON.stringify({ message: `Synced ${toCopy.length} files.` })











const AWS = require('aws-sdk');
const s3 = new AWS.S3();

const DEV_BUCKET = process.env.DEV_BUCKET;
const PROD_BUCKET = process.env.PROD_BUCKET;

exports.handler = async () => {
  try {
    const devObjects = await s3.listObjectsV2({ Bucket: DEV_BUCKET }).promise();
    const prodObjects = await s3.listObjectsV2({ Bucket: PROD_BUCKET }).promise();

    const prodMap = {};
    (prodObjects.Contents || []).forEach(o => prodMap[o.Key] = new Date(o.LastModified));

    const toCopy = (devObjects.Contents || []).filter(obj => {
      const prodDate = prodMap[obj.Key];
      return !prodDate || new Date(obj.LastModified) > prodDate;
    });

    const copyPromises = toCopy.map(obj =>
      s3.copyObject({
        Bucket: PROD_BUCKET,
        CopySource: `${DEV_BUCKET}/${encodeURIComponent(obj.Key)}`,
        Key: obj.Key
      }).promise()
    );

    await Promise.all(copyPromises);

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST'
      },
      body: JSON.stringify({ message: `Synced ${toCopy.length} files.` })
    };

  } catch (error) {
    console.error('Sync error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({ error: 'Internal error during sync', details: error.message })
    };
  }
};
